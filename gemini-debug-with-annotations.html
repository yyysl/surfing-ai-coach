<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Gemini API 调试 - 带标注显示</title>
    <link rel="stylesheet" href="surfing-analyzer.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        .debug-panel {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .debug-log {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        
        .debug-log.info {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .debug-log.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .debug-log.success {
            background: #d4edda;
            color: #155724;
        }
        
        .debug-log.warning {
            background: #fff3cd;
            color: #856404;
        }
        
        .test-section {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .test-button {
            background: linear-gradient(135deg, #4285f4 0%, #34a853 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            margin: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(66, 133, 244, 0.4);
        }
        
        .test-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .api-config {
            background: linear-gradient(135deg, #4285f4 0%, #34a853 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }
        
        .api-config input {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-success { background: #28a745; }
        .status-error { background: #dc3545; }
        .status-warning { background: #ffc107; }
        .status-info { background: #17a2b8; }

        /* 视频标注样式 */
        .video-wrapper {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }

        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .annotation {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }

        .annotation-arrow {
            position: relative;
            width: 100px;
            height: 50px;
        }

        .arrow-line {
            position: absolute;
            top: 50%;
            left: 0;
            width: 80px;
            height: 3px;
            background: #ff0000;
            transform: translateY(-50%);
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.8);
        }

        .arrow-head {
            position: absolute;
            top: 50%;
            right: 0;
            width: 0;
            height: 0;
            border-left: 15px solid #ff0000;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            transform: translateY(-50%);
            filter: drop-shadow(0 0 8px rgba(255, 0, 0, 0.8));
        }

        .arrow-text {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
        }

        .annotation-text {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            border: 2px solid #00d4ff;
        }

        .video-controls {
            margin-top: 15px;
            text-align: center;
        }

        .time-display {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            display: inline-block;
            margin: 10px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 头部 -->
        <header class="header">
            <div class="logo">
                <i class="fas fa-brain"></i>
                <h1>Google Gemini API 调试 - 带标注显示</h1>
            </div>
            <p class="subtitle">测试Google Gemini API并显示视频标注效果</p>
        </header>

        <!-- 主要内容区域 -->
        <main class="main-content">
            <!-- API配置 -->
            <div class="api-config">
                <h3><i class="fas fa-brain"></i> Google Gemini API 配置</h3>
                <div id="apiKeySection" style="margin-bottom: 15px;">
                    <label for="apiKeyInput">Google Gemini API Key:</label>
                    <input type="password" id="apiKeyInput" 
                           value="AIzaSyAMmui41ISIe88sqFmM4D9b2bG9vmBlqo4"
                           placeholder="输入您的Google Gemini API Key">
                </div>
                <button class="test-button" onclick="testApiKey()">测试连接</button>
                <div id="apiStatus" style="margin-top: 15px; font-weight: bold;"></div>
            </div>

            <!-- 调试日志面板 -->
            <div class="test-section">
                <h3><i class="fas fa-terminal"></i> 调试日志</h3>
                <div class="debug-panel" id="debugPanel">
                    <div class="debug-log info">调试面板已启动，等待操作...</div>
                </div>
                <button class="test-button" onclick="clearDebugLog()">清除日志</button>
            </div>

            <!-- 视频上传和标注显示 -->
            <div class="test-section">
                <h3><i class="fas fa-video"></i> 视频上传和标注显示</h3>
                <div style="margin-bottom: 15px;">
                    <input type="file" id="videoInput" accept="video/*" style="margin-bottom: 10px;">
                    <div id="videoInfo" style="color: #666; font-size: 14px;"></div>
                </div>
                
                <!-- 视频播放器带标注 -->
                <div id="videoPreviewSection" style="display: none;">
                    <div class="video-wrapper">
                        <video id="testVideo" controls style="max-width: 100%; border-radius: 10px;">
                            您的浏览器不支持视频播放
                        </video>
                        <div class="video-overlay" id="videoOverlay">
                            <!-- 标注将在这里显示 -->
                        </div>
                    </div>
                    
                    <div class="video-controls">
                        <div class="time-display" id="timeDisplay">00:00</div>
                        
                        <div style="background: rgba(0,0,0,0.1); padding: 10px; border-radius: 8px; margin: 10px 0;">
                            <div>
                                <button class="test-button" onclick="debugTools.startVideoAnalysis()">开始AI分析</button>
                                <button class="test-button" onclick="debugTools.testMockAnnotations()" style="background: #6f42c1;">测试模拟标注</button>
                                <button class="test-button" onclick="debugTools.clearAnnotations()">清除标注</button>
                                <button class="test-button" onclick="debugTools.showCoordinateGrid()" style="background: #28a745;">显示坐标网格</button>
                                <button class="test-button" onclick="debugTools.testAdaptiveCoordinates()" style="background: #17a2b8;">测试自适应坐标</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 分析结果 -->
            <div class="test-section" id="analysisResults" style="display: none;">
                <h3><i class="fas fa-chart-line"></i> 分析结果</h3>
                <div id="analysisContent" style="background: #f8f9fa; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 12px; white-space: pre-wrap;"></div>
            </div>
        </main>

        <!-- 底部信息 -->
        <footer class="footer">
            <p>&copy; 2024 冲浪AI教练. Gemini API调试工具</p>
        </footer>
    </div>

    <script>
        // 调试工具类
        class GeminiDebugWithAnnotations {
                    constructor() {
            this.debugPanel = document.getElementById('debugPanel');
                this.apiKey = 'AIzaSyAMmui41ISIe88sqFmM4D9b2bG9vmBlqo4'; // 默认API Key
            this.videoFile = null;
            this.videoElement = null;
            this.currentAnnotations = [];
            
            this.setupEventListeners();
        }

            setupEventListeners() {
                document.getElementById('videoInput').addEventListener('change', (e) => {
                    this.handleVideoSelect(e.target.files[0]);
                });
                
                document.getElementById('apiKeyInput').addEventListener('input', (e) => {
                    this.apiKey = e.target.value.trim();
                });
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logElement = document.createElement('div');
                logElement.className = `debug-log ${type}`;
                logElement.innerHTML = `[${timestamp}] ${message}`;
                this.debugPanel.appendChild(logElement);
                this.debugPanel.scrollTop = this.debugPanel.scrollHeight;
                
                console.log(`[DEBUG ${type.toUpperCase()}] ${message}`);
            }

            updateApiStatus(message, type = 'info') {
                const statusElement = document.getElementById('apiStatus');
                const statusClass = `status-${type}`;
                statusElement.innerHTML = `<span class="status-indicator ${statusClass}"></span>${message}`;
            }

            handleVideoSelect(file) {
                if (!file) return;
                
                this.log(`选择视频文件: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`, 'info');
                
                if (!file.type.startsWith('video/')) {
                    this.log('错误: 不是有效的视频文件', 'error');
                    return;
                }
                
                this.videoFile = file;
                this.displayVideo(file);
            }

            displayVideo(file) {
                const url = URL.createObjectURL(file);
                this.videoElement = document.getElementById('testVideo');
                this.videoElement.src = url;
                this.videoElement.load();
                
                document.getElementById('videoPreviewSection').style.display = 'block';
                
                this.videoElement.addEventListener('loadedmetadata', () => {
                    this.log(`视频信息: ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}, 时长: ${this.videoElement.duration}秒`, 'success');
                    document.getElementById('videoInfo').textContent = 
                        `尺寸: ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}, 时长: ${this.videoElement.duration}秒`;
                });

                // 监听视频播放时间更新
                this.videoElement.addEventListener('timeupdate', () => {
                    this.updateTimeDisplay();
                    this.drawCurrentAnnotations();
                });
            }

            updateTimeDisplay() {
                const currentTime = this.videoElement.currentTime;
                const minutes = Math.floor(currentTime / 60);
                const seconds = Math.floor(currentTime % 60);
                document.getElementById('timeDisplay').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            drawCurrentAnnotations() {
                if (!this.videoElement) return;
                
                const currentTime = this.videoElement.currentTime;
                const overlay = document.getElementById('videoOverlay');
                
                if (!overlay) return;
                
                // 清理所有现有标注
                overlay.innerHTML = '';
                
                // 获取当前时间的标注
                const currentAnnotations = this.getAnnotationsAtTime(currentTime);
                
                // 简单防重叠：限制同时显示的标注数量
                const maxAnnotations = 2;
                const displayAnnotations = currentAnnotations.slice(0, maxAnnotations);
                
                // 智能绘制标注，根据target调整位置
                displayAnnotations.forEach((annotation, index) => {
                    let adjustedAnnotation = { ...annotation }; // 复制对象避免修改原数据
                    
                    // 保持原始位置，箭头应该直接指向目标
                    // 不要偏移位置，让箭头准确指向冲浪者和海浪
                    adjustedAnnotation.position = annotation.position;
                    
                    // 如果有多个标注，防止重叠
                    if (index > 0) {
                        // 根据标注类型智能错开
                        const offset = annotation.target === 'surfer' ? 15 : 12;
                        adjustedAnnotation.position.y += offset;
                        
                        // 确保不超出边界
                        adjustedAnnotation.position.y = Math.min(adjustedAnnotation.position.y, 80);
                    }
                    
                    this.drawAnnotation(adjustedAnnotation, overlay);
                });
            }

            getAnnotationsAtTime(currentTime) {
                return this.currentAnnotations.filter(annotation => {
                    const startTime = annotation.timestamp || 0;
                    const endTime = startTime + (annotation.duration || 3);
                    const tolerance = 0.1;
                    
                    return currentTime >= (startTime - tolerance) && currentTime <= (endTime + tolerance);
                });
            }

            drawAnnotation(annotation, container) {
                const { type, position, text, color } = annotation;
                
                const annotationElement = document.createElement('div');
                annotationElement.className = `annotation annotation-${type}`;
                
                annotationElement.style.cssText = `
                    position: absolute;
                    left: ${position.x}%;
                    top: ${position.y}%;
                    pointer-events: none;
                    z-index: 10;
                `;
                
                if (type === 'arrow') {
                    // 恢复第一版本的简洁设计
                    const arrowColor = annotation.target === 'surfer' ? '#ff8800' : '#00aaff';
                    
                    annotationElement.innerHTML = `
                        <div class="clean-annotation" style="
                            display: flex;
                            align-items: center;
                            gap: 8px;
                        ">
                            <!-- 箭头线条 -->
                            <div class="arrow-line" style="
                                width: 60px;
                                height: 3px;
                                background: ${arrowColor};
                                position: relative;
                                box-shadow: 0 1px 3px rgba(0,0,0,0.3);
                            ">
                                <!-- 箭头头部 -->
                                <div class="arrow-head" style="
                                    position: absolute;
                                    right: -8px;
                                    top: 50%;
                                    transform: translateY(-50%);
                                    width: 0;
                                    height: 0;
                                    border-left: 8px solid ${arrowColor};
                                    border-top: 6px solid transparent;
                                    border-bottom: 6px solid transparent;
                                    filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
                                "></div>
                    </div>
                            
                            <!-- 文字标注 -->
                            <div class="annotation-text" style="
                                background: rgba(0, 0, 0, 0.85);
                                color: white;
                                padding: 6px 12px;
                                border-radius: 4px;
                                font-size: 14px;
                                font-weight: 500;
                                box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                                border-left: 3px solid ${arrowColor};
                                min-width: 80px;
                                white-space: nowrap;
                            ">${text}</div>
                    </div>
                `;
                } else if (type === 'text') {
                    annotationElement.innerHTML = `
                        <div class="annotation-text" style="border-color: ${color || '#00d4ff'};">
                            ${text}
                    </div>
                `;
            }

                container.appendChild(annotationElement);
            }

            // AI分析单个视频帧
            async analyzeFrame(timestamp, base64Image) {
                if (!this.apiKey) {
                    throw new Error('请先设置API Key');
                }
                
                this.log(`分析时间 ${timestamp.toFixed(1)}s 的帧...`, 'info');
                
                // 根据时间戳调整分析重点
                const analysisContext = this.getAnalysisContext(timestamp);
                
                const prompt = `作为专业冲浪教练，分析这张冲浪图片。

【分析背景】
当前阶段：${analysisContext.phase}
分析重点：${analysisContext.focus}
提示：${analysisContext.hints}

第一步：观察图片构图
- 冲浪者在画面中的什么位置？（左/中/右，上/中/下）
- 海浪在什么位置？（前景/背景，左/右侧）
- 拍摄角度是什么样的？（侧面/正面/远景/近景）

第二步：技术分析（结合当前阶段重点）
- 冲浪者的姿态有什么问题？
- 当前时机如何？
- 需要什么改进建议？

第三步：精确定位
仔细观察冲浪者和关键海浪的确切像素位置，用百分比坐标表示：
- X轴：0=最左边，50=中间，100=最右边  
- Y轴：0=最顶部，50=中间，100=最底部

返回JSON：
{
  "annotations": [
    {
      "type": "arrow",
      "target": "surfer",
      "position": {"x": 冲浪者身体中心的X坐标, "y": 冲浪者身体中心的Y坐标},
      "text": "简洁建议"
    },
    {
      "type": "arrow", 
      "target": "wave",
      "position": {"x": 重要海浪的X坐标, "y": 重要海浪的Y坐标},
      "text": "时机建议"
    }
  ]
}

要求：
- 坐标必须基于你看到的实际位置，不要使用固定数值
- 文字最多6个字
- 如果没有明显问题，返回空数组[]`;
                
                try {
                    const response = await apiManager.callWithRateLimit(async () => {
                        const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${this.apiKey}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                contents: [{
                                    parts: [
                                        { text: prompt },
                                        {
                                            inline_data: {
                                                mime_type: "image/jpeg",
                                                data: base64Image.split(',')[1]
                                            }
                                        }
                                    ]
                                }],
                                generationConfig: {
                                    temperature: 0.3,
                                    maxOutputTokens: 500 // 减少token使用
                                }
                            })
                        });
                        
                        if (res.status === 429) {
                            throw new Error('429');
                        } else if (!res.ok) {
                            const errorData = await res.json();
                            throw new Error(`API错误: ${res.status} ${errorData.error?.message || '未知错误'}`);
                        }
                        
                        return res;
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API错误: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const analysisText = data.candidates[0].content.parts[0].text;
                    
                    this.log(`时间 ${timestamp.toFixed(1)}s AI分析完成`, 'success');
                    this.log(`AI回复: ${analysisText}`, 'info');
                    
                    // 解析AI回复
                    return this.parseAIResponse(analysisText, timestamp);
                    
                    } catch (error) {
                    if (error.message.includes('429')) {
                        this.log(`时间 ${timestamp.toFixed(1)}s 分析被限流，已自动重试`, 'warning');
                        throw new Error('API配额限制，请稍后重试');
                    } else {
                        this.log(`时间 ${timestamp.toFixed(1)}s 分析失败: ${error.message}`, 'error');
                        throw error;
                    }
                }
            }

            // 解析AI回复JSON
            parseAIResponse(analysisText, timestamp) {
                try {
                    // 清理文本，移除markdown标记
                    let cleanText = analysisText.trim();
                    if (cleanText.startsWith('```json')) {
                        cleanText = cleanText.substring(7);
                    } else if (cleanText.startsWith('```')) {
                        cleanText = cleanText.substring(3);
                    }
                    if (cleanText.endsWith('```')) {
                        cleanText = cleanText.substring(0, cleanText.length - 3);
                    }
                    cleanText = cleanText.trim();
                    
                    const result = JSON.parse(cleanText);
                    
                    // 为每个标注添加时间戳和智能属性
                    if (result.annotations) {
                        result.annotations.forEach((annotation, index) => {
                            annotation.timestamp = timestamp;
                            annotation.duration = 2.5; // 显示2.5秒
                            annotation.id = `${timestamp}-${annotation.target || 'unknown'}-${index}`;
                            
                            // 根据target设置默认颜色
                            if (!annotation.color) {
                                annotation.color = annotation.target === 'surfer' ? '#ff8800' : '#00aaff';
                            }
                            
                            // 设置默认target
                            if (!annotation.target) {
                                annotation.target = 'surfer';
                            }
                            
                            // 坐标校正系统 - 确保箭头指向合理位置
                            annotation.position = this.correctAnnotationPosition(annotation);
                        });
                    }
                    
                    this.log(`解析成功，获得 ${result.annotations ? result.annotations.length : 0} 个标注`, 'success');
                    return result.annotations || [];
                    
                } catch (error) {
                    this.log(`解析AI回复失败: ${error.message}`, 'error');
                    this.log(`原始文本: ${analysisText}`, 'error');
                    return [];
                }
            }

            // 获取分析上下文，帮助AI理解视频阶段
            getAnalysisContext(timestamp) {
                const duration = this.videoElement ? this.videoElement.duration : 10;
                const progress = timestamp / duration;
                
                if (progress < 0.3) {
                    return {
                        phase: '起始阶段',
                        focus: '起乘动作和初始定位',
                        hints: '关注冲浪者是否成功抓到浪，身体平衡如何'
                    };
                } else if (progress < 0.7) {
                    return {
                        phase: '中段滑行',
                        focus: '滑行技巧和动作转换',
                        hints: '关注转向、回切等技术动作，以及与海浪的配合'
                    };
                } else {
                    return {
                        phase: '结束阶段', 
                        focus: '收尾动作或落水分析',
                        hints: '分析动作完成度和可能的改进点'
                    };
                }
            }

            // 智能坐标验证系统 - 移除固定范围限制，让AI自主判断
            correctAnnotationPosition(annotation) {
                let { x, y } = annotation.position;
                const target = annotation.target;
                
                // 基本边界检查 - 只检查是否在画面内
                const isOutOfBounds = x < 0 || x > 100 || y < 0 || y > 100;
                const isValidCoordinate = !isNaN(x) && !isNaN(y) && isFinite(x) && isFinite(y);
                
                if (!isValidCoordinate || isOutOfBounds) {
                    // 只在坐标完全无效时才使用后备位置
                    this.log(`坐标无效: ${annotation.target} (${x}, ${y})，使用后备位置`, 'warning');
                    
                    if (target === 'surfer') {
                        x = 50; // 画面中心
                        y = 45;
                    } else if (target === 'wave') {
                        x = 60; // 稍微偏右
                        y = 50;
                    }
                } else {
                    // 坐标有效，保持AI的原始判断
                    this.log(`坐标有效: ${annotation.target} 位置(${x}, ${y})`, 'success');
                }
                
                return { x, y };
            }

            // 开始视频分析
            async startVideoAnalysis() {
                if (!this.videoElement || this.videoElement.videoWidth === 0) {
                    this.log('错误: 请先上传并加载视频', 'error');
                    return;
                }
                
                if (!this.apiKey) {
                    this.log('错误: 请先设置API Key', 'error');
                    return;
                }
                
                this.log('开始冲浪视频分析...', 'info');
                
                // 清除旧标注
                this.currentAnnotations = [];
                this.clearAnnotations();
                
                try {
                                    const duration = this.videoElement.duration;
                const frameInterval = 4; // 增加到每4秒分析一帧，减少API调用
                const maxFrames = Math.min(3, Math.floor(duration / frameInterval)); // 最多3帧，避免429错误
                    
                    this.log(`视频时长: ${duration.toFixed(1)}s，将分析 ${maxFrames} 帧`, 'info');
                    
                    for (let i = 0; i < maxFrames; i++) {
                        const timestamp = i * frameInterval;
                        
                        try {
                            // 提取帧
                            const base64Image = await this.convertFrameToBase64(timestamp);
                            
                            // AI分析
                            const annotations = await this.analyzeFrame(timestamp, base64Image);
                            
                            // 添加到标注列表
                            this.currentAnnotations.push(...annotations);
                            
                            this.log(`第 ${i+1}/${maxFrames} 帧分析完成，获得 ${annotations.length} 个标注`, 'success');
                            
                            // 延迟避免API限制 - 增加延迟时间
                            if (i < maxFrames - 1) {
                                await new Promise(resolve => setTimeout(resolve, 5000)); // 增加到5秒
                            }
                            
                        } catch (error) {
                            this.log(`第 ${i+1} 帧分析失败: ${error.message}`, 'error');
                            // 继续分析下一帧
                        }
                    }
                    
                    this.log(`分析完成！共生成 ${this.currentAnnotations.length} 个标注`, 'success');
                    
                    // 立即显示当前时间的标注
                    this.drawCurrentAnnotations();
                    
                } catch (error) {
                    this.log(`视频分析失败: ${error.message}`, 'error');
                }
            }

            // 提取视频帧转为base64
            async convertFrameToBase64(timestamp) {
                return new Promise((resolve, reject) => {
                    try {
                        this.videoElement.currentTime = timestamp;
                        this.videoElement.onseeked = () => {
                            try {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                
                                canvas.width = this.videoElement.videoWidth;
                                canvas.height = this.videoElement.videoHeight;
                                
                                ctx.drawImage(this.videoElement, 0, 0);
                                const base64 = canvas.toDataURL('image/jpeg', 0.8);
                                
                                this.log(`成功提取 ${timestamp.toFixed(1)}s 的帧`, 'success');
                                resolve(base64);
            } catch (error) {
                                reject(error);
                            }
                        };
                        
                        // 超时处理
                        setTimeout(() => {
                            reject(new Error('提取帧超时'));
                        }, 5000);
                        
            } catch (error) {
                        reject(error);
                    }
                });
            }

            // 清除所有标注
            clearAnnotations() {
                this.currentAnnotations = [];
                const overlay = document.getElementById('videoOverlay');
                if (overlay) {
                    overlay.innerHTML = '';
                }
                this.log('已清除所有标注', 'info');
            }

            // 测试模拟标注
            testMockAnnotations() {
                if (!this.videoElement || this.videoElement.videoWidth === 0) {
                    this.log('错误: 请先上传并加载视频', 'error');
                    return;
                }

                this.log('开始测试模拟标注...', 'info');
                
                // 清除现有标注
                this.clearAnnotations();
                
                // 使用更准确的坐标，基于典型冲浪视频布局
                this.currentAnnotations = [
                    // 移除硬编码假标注 - 只使用AI分析结果
                ];

                this.log(`生成了 ${this.currentAnnotations.length} 个模拟标注`, 'success');
                this.log('标注将在视频播放时根据时间点显示', 'info');
                
                // 立即显示当前时间的标注
                this.drawCurrentAnnotations();
            }

            // 显示坐标网格，帮助调试标注位置
            showCoordinateGrid() {
                const overlay = document.getElementById('videoOverlay');
                if (!overlay) return;

                // 清除现有内容
                overlay.innerHTML = '';

                // 创建网格
                for (let x = 0; x <= 100; x += 10) {
                    for (let y = 0; y <= 100; y += 10) {
                        const gridPoint = document.createElement('div');
                        gridPoint.style.cssText = `
                            position: absolute;
                            left: ${x}%;
                            top: ${y}%;
                            width: 4px;
                            height: 4px;
                            background: rgba(255, 0, 0, 0.7);
                            border-radius: 50%;
                            transform: translate(-50%, -50%);
                            z-index: 20;
                        `;
                        
                        // 添加坐标标签
                        if (x % 20 === 0 && y % 20 === 0) {
                            const label = document.createElement('div');
                            label.style.cssText = `
                                position: absolute;
                                left: ${x}%;
                                top: ${y}%;
                                background: rgba(0, 0, 0, 0.8);
                                color: white;
                                padding: 2px 4px;
                                border-radius: 3px;
                                font-size: 10px;
                                transform: translate(-50%, -120%);
                                z-index: 21;
                            `;
                            label.textContent = `${x},${y}`;
                            overlay.appendChild(label);
                        }
                        
                        overlay.appendChild(gridPoint);
                    }
                }

                // 高亮典型位置
                const keyPositions = [
                    { x: 50, y: 40, label: '冲浪者中心', color: '#ff8800' },
                    { x: 70, y: 50, label: '前方海浪', color: '#00aaff' },
                    { x: 30, y: 30, label: '后方海浪', color: '#00aaff' }
                ];

                keyPositions.forEach(pos => {
                    const marker = document.createElement('div');
                    marker.style.cssText = `
                        position: absolute;
                        left: ${pos.x}%;
                        top: ${pos.y}%;
                        width: 8px;
                        height: 8px;
                        background: ${pos.color};
                        border: 2px solid white;
                        border-radius: 50%;
                        transform: translate(-50%, -50%);
                        z-index: 25;
                    `;
                    
                    const label = document.createElement('div');
                    label.style.cssText = `
                        position: absolute;
                        left: ${pos.x}%;
                        top: ${pos.y}%;
                        background: ${pos.color};
                        color: white;
                        padding: 4px 8px;
                        border-radius: 4px;
                        font-size: 12px;
                        font-weight: bold;
                        transform: translate(-50%, -150%);
                        z-index: 26;
                        white-space: nowrap;
                    `;
                    label.textContent = pos.label;
                    
                    overlay.appendChild(marker);
                    overlay.appendChild(label);
                });

                this.log('坐标网格已显示，红点表示网格点，彩色点表示推荐位置', 'success');
                
                // 5秒后自动清除网格
                setTimeout(() => {
                    this.clearAnnotations();
                    this.log('坐标网格已自动清除', 'info');
                }, 8000);
            }

            // 测试自适应坐标系统
            testAdaptiveCoordinates() {
                if (!this.videoElement || this.videoElement.videoWidth === 0) {
                    this.log('错误: 请先上传并加载视频', 'error');
                    return;
                }

                this.log('开始测试自适应坐标系统...', 'info');
                
                // 清除现有标注
                this.clearAnnotations();
                
                // 模拟不同构图的视频场景
                const testScenarios = [
                    {
                        name: '左侧冲浪者',
                        surfer: { x: 25, y: 35 },
                        wave: { x: 65, y: 45 },
                        description: '冲浪者在画面左侧的场景'
                    },
                    {
                        name: '右侧冲浪者', 
                        surfer: { x: 75, y: 40 },
                        wave: { x: 35, y: 50 },
                        description: '冲浪者在画面右侧的场景'
                    },
                    {
                        name: '远景拍摄',
                        surfer: { x: 50, y: 65 },
                        wave: { x: 50, y: 30 },
                        description: '远距离拍摄，冲浪者较小'
                    },
                    {
                        name: '近景特写',
                        surfer: { x: 45, y: 25 },
                        wave: { x: 70, y: 35 },
                        description: '近距离特写，冲浪者占据大部分画面'
                    }
                ];

                let currentScenario = 0;
                
                const showNextScenario = () => {
                    if (currentScenario >= testScenarios.length) {
                        this.log('✅ 自适应坐标测试完成', 'success');
                        return;
                    }
                    
                    const scenario = testScenarios[currentScenario];
                    this.log(`测试场景 ${currentScenario + 1}: ${scenario.name}`, 'info');
                    this.log(`场景描述: ${scenario.description}`, 'info');
                    
                    // 清除之前的标注
                    this.clearAnnotations();
                    
                    // 创建当前场景的标注
                    this.currentAnnotations = [
                        // 移除测试假数据 - 只使用AI真实分析
                    ];
                    
                    // 显示标注
                    this.drawCurrentAnnotations();
                    
                    currentScenario++;
                    
                    // 3秒后显示下一个场景
                    setTimeout(showNextScenario, 3000);
                };
                
                // 开始展示
                showNextScenario();
            }
        }

        // 全局调试工具实例
        const debugTools = new GeminiDebugWithAnnotations();

        // API调用辅助函数，带重试和频率限制
        class APIManager {
            constructor() {
                this.lastRequestTime = 0;
                this.minInterval = 2000; // 最小间隔2秒
                this.maxRetries = 3;
            }

            async callWithRateLimit(apiCall) {
                // 频率限制
                const now = Date.now();
                const timeSinceLastRequest = now - this.lastRequestTime;
                if (timeSinceLastRequest < this.minInterval) {
                    const waitTime = this.minInterval - timeSinceLastRequest;
                    debugTools.log(`频率限制：等待 ${waitTime}ms...`, 'warning');
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }

                this.lastRequestTime = Date.now();
                return await this.retryWithBackoff(apiCall);
            }

            async retryWithBackoff(apiCall, retryCount = 0) {
                try {
                    return await apiCall();
                } catch (error) {
                    if (error.message.includes('429') && retryCount < this.maxRetries) {
                        const backoffTime = Math.pow(2, retryCount) * 3000; // 指数退避: 3s, 6s, 12s
                        debugTools.log(`遇到429错误，${backoffTime/1000}秒后重试...`, 'warning');
                        await new Promise(resolve => setTimeout(resolve, backoffTime));
                        return this.retryWithBackoff(apiCall, retryCount + 1);
                    }
                    throw error;
                }
            }
        }

        const apiManager = new APIManager();

        // 测试API Key函数
        async function testApiKey() {
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            
            if (!apiKey) {
                debugTools.log('错误: 请输入API Key', 'error');
                debugTools.updateApiStatus('请输入API Key', 'error');
                return;
            }
            
            debugTools.apiKey = apiKey;
            debugTools.log('开始测试API连接...', 'info');
            debugTools.updateApiStatus('测试中...', 'info');
            
            try {
                const result = await apiManager.callWithRateLimit(async () => {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{ text: "简单测试" }]
                            }],
                            generationConfig: {
                                maxOutputTokens: 50 // 减少token使用
                            }
                        })
                    });
                    
                    if (response.status === 429) {
                        throw new Error('429');
                    } else if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`HTTP ${response.status}: ${errorData.error?.message || '未知错误'}`);
                    }
                    
                    return response;
                });
                
                debugTools.log('✅ API连接测试成功！', 'success');
                debugTools.updateApiStatus('API连接正常', 'success');
                
            } catch (error) {
                if (error.message.includes('429')) {
                    debugTools.log(`❌ API配额限制：请稍后再试或检查您的配额状态`, 'error');
                    debugTools.updateApiStatus('API配额已满，请稍后重试', 'error');
                } else {
                    debugTools.log(`❌ API连接测试失败: ${error.message}`, 'error');
                    debugTools.updateApiStatus('API连接失败', 'error');
                }
            }
        }

        // 清除调试日志
        function clearDebugLog() {
            const debugPanel = document.getElementById('debugPanel');
            debugPanel.innerHTML = '<div class="debug-log info">调试面板已清空</div>';
        }

        document.addEventListener('DOMContentLoaded', () => {
            debugTools.log('AI视频分析工具已加载', 'success');
            debugTools.log('默认API Key已设置，正在测试连接...', 'info');
            
            // 自动测试默认API Key
            setTimeout(() => {
                testApiKey();
            }, 1000);
        });
    </script>
</body>
</html>
