<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çº¯å‡€AIå†²æµªåˆ†æç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            padding: 30px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #eee;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.2em;
        }

        .upload-section {
            margin-bottom: 30px;
            padding: 30px;
            border: 3px dashed #4285f4;
            border-radius: 15px;
            text-align: center;
            background: #f8f9ff;
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            border-color: #34a853;
            background: #f0fff4;
        }

        .upload-section.dragover {
            border-color: #ea4335;
            background: #fff5f5;
        }

        .api-key-section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f5f5f5;
            border-radius: 10px;
        }

        .api-key-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .api-key-input:focus {
            outline: none;
            border-color: #4285f4;
        }

        .video-section {
            margin-bottom: 30px;
            display: none;
        }

        .video-container {
            position: relative;
            display: inline-block;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .video-player {
            max-width: 100%;
            height: auto;
            display: block;
        }

        .annotation-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .controls {
            margin: 20px 0;
            text-align: center;
        }

        .pause-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 87, 34, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            z-index: 1000;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        .btn {
            background: linear-gradient(135deg, #4285f4 0%, #34a853 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(66, 133, 244, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .progress-section {
            display: none;
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4285f4, #34a853);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }

        .analysis-section {
            display: none;
            margin-top: 30px;
        }

        .current-analysis {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .analysis-results {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .analysis-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid #4285f4;
        }

        .time-stamp {
            font-weight: bold;
            color: #4285f4;
            margin-bottom: 10px;
        }

        .analysis-text {
            color: #333;
            line-height: 1.6;
        }

        .annotation-controls {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .slider-control {
            margin: 10px 0;
        }

        .slider {
            width: 200px;
            margin: 0 10px;
        }

        .error-message {
            background: #fee;
            color: #d33;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            border-left: 4px solid #d33;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ„â€â™‚ï¸ çº¯å‡€AIå†²æµªåˆ†æç³»ç»Ÿ</h1>
            <p>100% AIé©±åŠ¨ï¼Œé›¶å‡æ•°æ®ï¼ŒçœŸå®åˆ†æ</p>
        </div>

        <div class="api-key-section">
            <h3>ğŸ”‘ Gemini API Key</h3>
            <input type="password" id="apiKey" class="api-key-input" placeholder="è¯·è¾“å…¥æ‚¨çš„ Gemini API Key">
        </div>

        <div class="upload-section" id="uploadArea">
            <h3>ğŸ“¹ ä¸Šä¼ å†²æµªè§†é¢‘</h3>
            <p>æ‹–æ‹½è§†é¢‘æ–‡ä»¶åˆ°æ­¤å¤„ï¼Œæˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</p>
            <button class="btn" onclick="document.getElementById('fileInput').click()">
                é€‰æ‹©è§†é¢‘æ–‡ä»¶
            </button>
            <input type="file" id="fileInput" accept="video/*" style="display: none;">
        </div>

        <div class="video-section" id="videoSection">
            <div class="video-container" id="videoContainer">
                <video id="videoPlayer" class="video-player" controls>
                    æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘æ’­æ”¾ã€‚
                </video>
                <canvas id="annotationCanvas" class="annotation-canvas"></canvas>
            </div>

            <div class="annotation-controls">
                <h4>ğŸ¨ æ ‡æ³¨æ§åˆ¶</h4>
                <div class="slider-control">
                    <label>æ–‡å­—é€æ˜åº¦: </label>
                    <input type="range" id="opacitySlider" class="slider" min="0" max="100" value="70" 
                           onchange="updateOpacity(this.value)">
                    <span id="opacityValue">70%</span>
                </div>
                <label>
                    <input type="checkbox" id="showShadow" checked onchange="toggleShadow()"> æ–‡å­—é˜´å½±
                </label>
                <br>
                <label>
                    <input type="checkbox" id="showAnnotations" checked onchange="toggleAnnotations()"> æ˜¾ç¤ºæ ‡æ³¨
                </label>
            </div>

            <div class="controls">
                <button class="btn" id="analyzeBtn" onclick="startAIAnalysis()">
                    ğŸ¤– å¼€å§‹AIåˆ†æ
                </button>
            </div>
        </div>

        <div class="progress-section" id="progressSection">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
            <div id="progressText">å‡†å¤‡ä¸­...</div>
        </div>

        <div class="analysis-section" id="analysisSection">
            <div class="current-analysis" id="currentAnalysis" style="display: none;">
                <h4>ğŸ” å½“å‰æ—¶é—´ç‚¹åˆ†æ</h4>
                <div id="currentAnalysisText"></div>
            </div>

            <div class="analysis-results" id="analysisResults">
                <h4>ğŸ“Š AIåˆ†æç»“æœ</h4>
                <div id="analysisContent"></div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let currentVideo = null;
        let analysisResults = [];
        let annotationsVisible = true;
        let textOpacity = 0.7;
        let showShadow = true;
        let canvas = null;
        let ctx = null;
        let isPausedForAnnotation = false;
        let lastPausedTime = 0; // è®°å½•ä¸Šæ¬¡æš‚åœçš„æ—¶é—´ç‚¹

        // æ–‡ä»¶ä¸Šä¼ å¤„ç†
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                loadVideo(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadVideo(e.target.files[0]);
            }
        });

        // åŠ è½½è§†é¢‘
        function loadVideo(file) {
            if (!file.type.startsWith('video/')) {
                showError('è¯·é€‰æ‹©è§†é¢‘æ–‡ä»¶');
                return;
            }

            currentVideo = file;
            const videoPlayer = document.getElementById('videoPlayer');
            const videoSection = document.getElementById('videoSection');
            
            const url = URL.createObjectURL(file);
            videoPlayer.src = url;
            videoSection.style.display = 'block';
            
            videoPlayer.addEventListener('loadedmetadata', setupCanvas);
            videoPlayer.addEventListener('timeupdate', updateCurrentAnnotations);
            videoPlayer.addEventListener('play', () => {
                // ç”¨æˆ·æ‰‹åŠ¨æ’­æ”¾æ—¶é‡ç½®æš‚åœçŠ¶æ€
                if (isPausedForAnnotation) {
                    console.log('ğŸ”„ ç”¨æˆ·æ‰‹åŠ¨æ’­æ”¾ï¼Œé‡ç½®æš‚åœçŠ¶æ€');
                    isPausedForAnnotation = false;
                    hidePauseIndicator();
                }
            });
            
            // è§†é¢‘é‡æ–°åŠ è½½æ—¶é‡ç½®æš‚åœè®°å½•
            videoPlayer.addEventListener('loadstart', () => {
                lastPausedTime = 0;
                isPausedForAnnotation = false;
                console.log('ğŸ”„ è§†é¢‘é‡æ–°åŠ è½½ï¼Œé‡ç½®æš‚åœè®°å½•');
            });
            
            console.log('è§†é¢‘å·²åŠ è½½:', file.name);
        }

        // è®¾ç½®Canvas
        function setupCanvas() {
            const videoPlayer = document.getElementById('videoPlayer');
            canvas = document.getElementById('annotationCanvas');
            
            console.log('ğŸ¨ è®¾ç½®Canvas:', { 
                videoWidth: videoPlayer.videoWidth, 
                videoHeight: videoPlayer.videoHeight,
                canvasFound: !!canvas
            });
            
            canvas.width = videoPlayer.videoWidth;
            canvas.height = videoPlayer.videoHeight;
            canvas.style.width = videoPlayer.offsetWidth + 'px';
            canvas.style.height = videoPlayer.offsetHeight + 'px';
            
            ctx = canvas.getContext('2d');
            console.log('âœ… Canvasè®¾ç½®å®Œæˆ:', { canvasWidth: canvas.width, canvasHeight: canvas.height, hasCtx: !!ctx });
        }

        // æ›´æ–°é€æ˜åº¦
        function updateOpacity(value) {
            textOpacity = value / 100;
            document.getElementById('opacityValue').textContent = value + '%';
        }

        // åˆ‡æ¢é˜´å½±
        function toggleShadow() {
            showShadow = document.getElementById('showShadow').checked;
        }

        // åˆ‡æ¢æ ‡æ³¨æ˜¾ç¤º
        function toggleAnnotations() {
            annotationsVisible = document.getElementById('showAnnotations').checked;
            if (!annotationsVisible && ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                document.getElementById('currentAnalysis').style.display = 'none';
            }
        }

        // å¼€å§‹AIåˆ†æ
        async function startAIAnalysis() {
            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) {
                showError('è¯·è¾“å…¥ Gemini API Key');
                return;
            }

            if (!currentVideo) {
                showError('è¯·å…ˆä¸Šä¼ è§†é¢‘');
                return;
            }

            const analyzeBtn = document.getElementById('analyzeBtn');
            const progressSection = document.getElementById('progressSection');
            
            analyzeBtn.disabled = true;
            analyzeBtn.textContent = 'åˆ†æä¸­...';
            progressSection.style.display = 'block';
            analysisResults = [];

            try {
                // ç¬¬ä¸€æ­¥ï¼šAIæ™ºèƒ½è¯†åˆ«å…³é”®æ—¶åˆ»
                updateProgress(20, 'AIæ­£åœ¨è¯†åˆ«å…³é”®æ—¶åˆ»...');
                const keyMoments = await identifyKeyMoments(apiKey);
                
                if (!keyMoments || keyMoments.length === 0) {
                    throw new Error('AIæœªèƒ½è¯†åˆ«åˆ°å…³é”®æ—¶åˆ»');
                }

                // ç¬¬äºŒæ­¥ï¼šåˆ†ææ¯ä¸ªå…³é”®æ—¶åˆ»
                for (let i = 0; i < keyMoments.length; i++) {
                    const progress = 20 + ((i + 1) / keyMoments.length) * 70;
                    updateProgress(progress, `åˆ†æå…³é”®æ—¶åˆ» ${i + 1}/${keyMoments.length}: ${keyMoments[i].description}`);
                    
                    const analysis = await analyzeKeyMoment(keyMoments[i], apiKey);
                    analysisResults.push(analysis);
                    console.log('ğŸ“Š åˆ†æç»“æœå·²ä¿å­˜:', { timePoint: analysis.timePoint, annotationsCount: analysis.annotations.length });
                    
                    // APIè°ƒç”¨é—´éš”
                    if (i < keyMoments.length - 1) {
                        await delay(2000);
                    }
                }

                updateProgress(100, 'åˆ†æå®Œæˆï¼');
                displayResults();
                
            } catch (error) {
                showError('åˆ†æå¤±è´¥: ' + error.message);
            } finally {
                analyzeBtn.disabled = false;
                analyzeBtn.textContent = 'ğŸ¤– å¼€å§‹AIåˆ†æ';
                progressSection.style.display = 'none';
            }
        }

        // AIè¯†åˆ«å…³é”®æ—¶åˆ»
        async function identifyKeyMoments(apiKey) {
            const videoPlayer = document.getElementById('videoPlayer');
            const duration = videoPlayer.duration;
            
            // æå–é¢„è§ˆå¸§
            const previewFrames = [];
            const frameCount = Math.min(8, Math.ceil(duration / 3));
            
            for (let i = 0; i < frameCount; i++) {
                const timePoint = (duration / frameCount) * i;
                const frameData = await extractFrame(timePoint);
                previewFrames.push({
                    time: timePoint,
                    base64: frameData
                });
            }

            const prompt = `ä½ æ˜¯ä¸“ä¸šå†²æµªæ•™ç»ƒã€‚è§‚å¯Ÿè¿™${frameCount}ä¸ªè§†é¢‘å¸§ï¼ˆæ€»æ—¶é•¿${duration.toFixed(1)}ç§’ï¼‰ï¼Œè¯†åˆ«æœ€å€¼å¾—åˆ†æçš„å…³é”®æ—¶åˆ»ã€‚

è¦æ±‚ï¼š
1. ä»”ç»†è§‚å¯Ÿæ¯ä¸€å¸§çš„å†²æµªåŠ¨ä½œ
2. é€‰æ‹©2-5ä¸ªæœ€å…³é”®çš„æŠ€æœ¯æ—¶åˆ»
3. é¿å…é€‰æ‹©æ¨¡ç³Šæˆ–é‡å¤çš„æ—¶é—´ç‚¹
4. æ¯ä¸ªæ—¶åˆ»å¿…é¡»æœ‰æ˜ç¡®çš„åˆ†æä»·å€¼

è¿”å›JSONæ ¼å¼ï¼š
{
  "keyMoments": [
    {
      "time": æ—¶é—´ï¼ˆç§’ï¼‰,
      "description": "è¿™ä¸ªæ—¶åˆ»çš„ç‰¹ç‚¹æè¿°"
    }
  ]
}

è¯·åŸºäºå®é™…è§‚å¯Ÿé€‰æ‹©ï¼Œä¸è¦ä½¿ç”¨å›ºå®šæ—¶é—´ç‚¹ã€‚`;

            const parts = [{ text: prompt }];
            previewFrames.forEach(frame => {
                parts.push({
                    inline_data: {
                        mime_type: "image/jpeg",
                        data: frame.base64
                    }
                });
            });

            const response = await callGeminiAPI(apiKey, parts);
            return parseGeminiResponse(response).keyMoments;
        }

        // åˆ†æå…³é”®æ—¶åˆ»
        async function analyzeKeyMoment(moment, apiKey) {
            const frameData = await extractFrame(moment.time);
            
            const prompt = `ä½ æ˜¯ä¸“ä¸šå†²æµªæ•™ç»ƒï¼Œä»”ç»†åˆ†æè¿™ä¸ªè§†é¢‘å¸§ï¼ˆ${moment.time.toFixed(1)}ç§’ - ${moment.description}ï¼‰ã€‚

å…³é”®è¦æ±‚ï¼š
1. ç”»é¢åæ ‡ç³»ï¼šå·¦ä¸Šè§’(0,0)ï¼Œå³ä¸‹è§’(100,100)ä¸ºç™¾åˆ†æ¯”åæ ‡
2. ä»”ç»†è§‚å¯Ÿç”»é¢ï¼Œæ‰¾åˆ°å†²æµªè€…ã€å†²æµªæ¿ã€å…³é”®æ³¢æµªçš„å®é™…ä½ç½®
3. åªæœ‰å½“ä½ èƒ½æ˜ç¡®çœ‹åˆ°å¹¶ç¡®å®šä½ç½®æ—¶ï¼Œæ‰ç”Ÿæˆæ ‡æ³¨
4. åæ ‡å¿…é¡»æ˜¯ä½ å®é™…è§‚å¯Ÿåˆ°çš„ä½ç½®ï¼Œä¸è¦çŒœæµ‹
5. å†²æµªè€…é€šå¸¸åœ¨ç”»é¢ä¸­å¤®åŒºåŸŸ(30-70%, 30-70%)ï¼Œä¸è¦æ ‡æ³¨åˆ°ç”»é¢è¾¹ç¼˜
6. å¦‚æœçœ‹ä¸æ¸…æ¥šå…·ä½“ä½ç½®ï¼Œå°±ä¸è¦ç”Ÿæˆæ ‡æ³¨

åˆ†ææ­¥éª¤ï¼š
ç¬¬ä¸€æ­¥ï¼šè§‚å¯Ÿè¯†åˆ«
- åœ¨ç”»é¢ä¸­æ‰¾åˆ°å†²æµªè€…çš„å…·ä½“ä½ç½®
- æ‰¾åˆ°å†²æµªæ¿çš„å…·ä½“ä½ç½®  
- è¯†åˆ«å…³é”®æ³¢æµªåŒºåŸŸçš„ä½ç½®

ç¬¬äºŒæ­¥ï¼šæŠ€æœ¯è¯„ä¼°
- è¯„ä¼°ä½ è§‚å¯Ÿåˆ°çš„æŠ€æœ¯é—®é¢˜
- åˆ†æå§¿æ€å’ŒåŠ¨ä½œçš„å…·ä½“é—®é¢˜
- æ€è€ƒæ”¹è¿›çš„å…·ä½“æ–¹æ³•

ç¬¬ä¸‰æ­¥ï¼šç²¾ç¡®æ ‡æ³¨
ä¸ºä½ æ˜ç¡®è§‚å¯Ÿåˆ°çš„é—®é¢˜åˆ›å»ºæ ‡æ³¨ï¼Œæ¯ä¸ªæ ‡æ³¨è¦åŒ…å«ï¼š
1. å…·ä½“é—®é¢˜è¯†åˆ«
2. æ”¹è¿›å»ºè®®

JSONæ ¼å¼ï¼š
{
  "analysis": "è¯¦ç»†åˆ†ææ–‡å­—",
  "annotations": [
    {
      "x": ä½ è§‚å¯Ÿåˆ°çš„å®é™…xç™¾åˆ†æ¯”ä½ç½®,
      "y": ä½ è§‚å¯Ÿåˆ°çš„å®é™…yç™¾åˆ†æ¯”ä½ç½®,
      "text": "å…·ä½“é—®é¢˜æè¿°å’Œæ”¹è¿›å»ºè®®",
      "type": "surfer/board/wave"
    }
  ]
}

æ ‡æ³¨æ–‡å­—è¦æ±‚ï¼š
- åŸºäºä½ çš„è§‚å¯Ÿï¼Œæè¿°å…·ä½“é—®é¢˜
- å¦‚æœå¯èƒ½ï¼Œæä¾›æ”¹è¿›å»ºè®®
- æ€»é•¿åº¦æ§åˆ¶åœ¨25å­—ä»¥å†…ï¼Œç®€æ´å®ç”¨
- åªå†™ä½ çœŸæ­£è§‚å¯Ÿåˆ°å’Œæƒ³åˆ°çš„å†…å®¹

é‡è¦è§„åˆ™ï¼š
- åæ ‡å¿…é¡»åŸºäºä½ çš„çœŸå®è§‚å¯Ÿï¼Œä¸è¦ä½¿ç”¨ä»»ä½•é¢„è®¾æ•°å€¼
- å¦‚æœçœ‹ä¸æ¸…æ¥šæˆ–ä¸ç¡®å®šï¼Œå°±ä¸è¦ç”Ÿæˆé‚£ä¸ªæ ‡æ³¨
- æ¯ä¸ªæ ‡æ³¨åŸºäºçœŸå®è§‚å¯Ÿï¼Œä¸å¼ºåˆ¶åŒ…å«å»ºè®®
- æœ€å¤šç”Ÿæˆ3ä¸ªæœ€é‡è¦çš„æ ‡æ³¨`;

            const parts = [
                { text: prompt },
                {
                    inline_data: {
                        mime_type: "image/jpeg",
                        data: frameData
                    }
                }
            ];

            const response = await callGeminiAPI(apiKey, parts);
            
            // è°ƒè¯•æ—¥å¿—ï¼šæ˜¾ç¤ºAIåŸå§‹å“åº”
            console.log('ğŸ¤– AIåŸå§‹å“åº”:', response);
            console.log('ğŸ“ AIå“åº”æ–‡æœ¬:', response.candidates?.[0]?.content?.parts?.[0]?.text);
            
            const result = parseGeminiResponse(response);
            
            // è°ƒè¯•æ—¥å¿—ï¼šæ˜¾ç¤ºè§£æç»“æœ
            console.log('ğŸ“Š è§£æåçš„ç»“æœ:', result);
            
            // éªŒè¯å’Œè¿‡æ»¤åæ ‡
            const validAnnotations = validateAnnotations(result.annotations || []);
            
            console.log('âœ… éªŒè¯åçš„æœ‰æ•ˆæ ‡æ³¨:', validAnnotations);
            
            return {
                timePoint: moment.time,
                description: moment.description,
                analysis: result.analysis,
                annotations: validAnnotations
            };
        }

        // éªŒè¯æ ‡æ³¨åæ ‡
        function validateAnnotations(annotations) {
            return annotations.filter(annotation => {
                // æ£€æŸ¥åæ ‡æ˜¯å¦ä¸ºæœ‰æ•ˆæ•°å­—
                const x = parseFloat(annotation.x);
                const y = parseFloat(annotation.y);
                
                console.log('éªŒè¯æ ‡æ³¨åæ ‡:', {
                    type: annotation.type,
                    x: x,
                    y: y,
                    text: annotation.text,
                    original: annotation
                });
                
                if (isNaN(x) || isNaN(y)) {
                    console.log('âŒ è·³è¿‡æ— æ•ˆåæ ‡:', annotation);
                    return false;
                }
                
                // æ›´ä¸¥æ ¼çš„åæ ‡èŒƒå›´éªŒè¯
                // å†²æµªè€…æ´»åŠ¨çš„æ ¸å¿ƒåŒºåŸŸé€šå¸¸åœ¨ç”»é¢çš„30%-70%èŒƒå›´å†…
                if (x < 20 || x > 80 || y < 20 || y > 80) {
                    console.log('âŒ è·³è¿‡è¾¹ç¼˜åæ ‡ (è¶…å‡º20-80%èŒƒå›´):', { x, y, type: annotation.type });
                    return false;
                }
                
                // é¢å¤–çš„åˆç†æ€§æ£€æŸ¥ï¼šå†²æµªè€…é€šå¸¸ä¸ä¼šåœ¨ç”»é¢æœ€ä¸Šæ–¹ï¼ˆå¤©ç©ºï¼‰æˆ–æœ€ä¸‹æ–¹ï¼ˆå‰æ™¯ï¼‰
                if (annotation.type === 'surfer' && (y < 30 || y > 70)) {
                    console.log('âŒ è·³è¿‡ä¸åˆç†çš„å†²æµªè€…ä½ç½®:', { x, y });
                    return false;
                }
                
                // æ‰€æœ‰æ ‡æ³¨éƒ½åº”è¯¥åœ¨ç”»é¢ä¸­å¤®åŒºåŸŸï¼Œé¿å…è¾¹ç¼˜
                if (x < 25 || x > 75 || y < 25 || y > 75) {
                    console.log('âŒ è·³è¿‡è¾¹ç¼˜æ ‡æ³¨ (è¶…å‡º25-75%èŒƒå›´):', { x, y, type: annotation.type });
                    return false;
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„æ–‡å­—æè¿°
                if (!annotation.text || annotation.text.trim().length < 2) {
                    console.log('âŒ è·³è¿‡æ— æ•ˆæ–‡å­—:', annotation);
                    return false;
                }
                
                console.log('âœ… é€šè¿‡éªŒè¯çš„æ ‡æ³¨:', { x, y, type: annotation.type, text: annotation.text });
                return true;
            });
        }

        // æå–è§†é¢‘å¸§
        async function extractFrame(timePoint) {
            return new Promise((resolve) => {
                const videoPlayer = document.getElementById('videoPlayer');
                videoPlayer.currentTime = timePoint;
                
                videoPlayer.onseeked = () => {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    tempCanvas.width = Math.min(videoPlayer.videoWidth, 800);
                    tempCanvas.height = Math.min(videoPlayer.videoHeight, 600);
                    
                    tempCtx.drawImage(videoPlayer, 0, 0, tempCanvas.width, tempCanvas.height);
                    
                    const base64 = tempCanvas.toDataURL('image/jpeg', 0.8);
                    resolve(base64.split(',')[1]);
                };
            });
        }

        // è°ƒç”¨Gemini API
        async function callGeminiAPI(apiKey, parts) {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{ parts: parts }],
                    generationConfig: {
                        maxOutputTokens: 1000,
                        temperature: 0.7
                    }
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} - ${errorText}`);
            }

            return await response.json();
        }

        // è§£æGeminiå“åº”
        function parseGeminiResponse(data) {
            if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                throw new Error('APIå“åº”æ ¼å¼å¼‚å¸¸');
            }
            
            const responseText = data.candidates[0].content.parts[0].text;
            console.log('ğŸ” å°è¯•è§£æAIå“åº”æ–‡æœ¬é•¿åº¦:', responseText.length);
            
            try {
                // å°è¯•å¤šç§JSONæå–æ–¹æ³•
                let cleanText = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                
                // å¦‚æœæ‰¾ä¸åˆ°å®Œæ•´JSONï¼Œå°è¯•æå–JSONéƒ¨åˆ†
                const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    cleanText = jsonMatch[0];
                    console.log('ğŸ“ æå–åˆ°JSONç‰‡æ®µ:', cleanText.substring(0, 100) + '...');
                }
                
                const parsed = JSON.parse(cleanText);
                console.log('âœ… JSONè§£ææˆåŠŸ:', parsed);
                
                // ä¼˜åŒ–æ ‡æ³¨æ–‡å­—ï¼Œç¡®ä¿ç®€æ´æ˜“è¯»
                if (parsed.annotations && Array.isArray(parsed.annotations)) {
                    console.log('ğŸ“‹ å¤„ç†', parsed.annotations.length, 'ä¸ªæ ‡æ³¨');
                    parsed.annotations = parsed.annotations.map((annotation, index) => {
                        const originalText = annotation.text || '';
                        const friendlyText = createFriendlyText(originalText);
                        
                        // è°ƒè¯•ä¿¡æ¯ï¼šæ˜¾ç¤ºåŸæ–‡å’Œç¼©å†™å¯¹æ¯”
                        if (originalText !== friendlyText) {
                            console.log(`æ–‡å­—ç¼©å†™[${index}]:`, originalText, '->', friendlyText);
                        }
                        
                        return {
                            ...annotation,
                            text: friendlyText,
                            originalText: originalText  // ä¿å­˜åŸæ–‡
                        };
                    });
                }
                
                return parsed;
            } catch (parseError) {
                console.log('âŒ JSONè§£æå¤±è´¥:', parseError.message);
                console.log('ğŸ“„ åŸå§‹æ–‡æœ¬:', responseText.substring(0, 200) + '...');
                
                // å¦‚æœä¸æ˜¯JSONæ ¼å¼ï¼Œè¿”å›çº¯æ–‡å­—åˆ†æï¼Œä¸ç”Ÿæˆæ ‡æ³¨
                return extractInfoFromText(responseText);
            }
        }

        // åˆ›å»ºå‹å¥½çš„æ ‡æ³¨æ–‡å­—
        function createFriendlyText(originalText) {
            if (!originalText) return '';
            
            // å¦‚æœå·²ç»å¾ˆçŸ­å°±ç›´æ¥è¿”å›
            if (originalText.length <= 25) return originalText;
            
            // å…³é”®è¯æ˜ å°„ - å°†æŠ€æœ¯æœ¯è¯­è½¬æ¢ä¸ºç®€æ´è¡¨è¾¾
            const keywordMap = {
                'é‡å¿ƒ': 'é‡å¿ƒ',
                'å¹³è¡¡': 'å¹³è¡¡',
                'å§¿æ€': 'å§¿æ€',
                'å‰å€¾': 'å‰å€¾',
                'åå€¾': 'åå€¾',
                'åé«˜': 'è¿‡é«˜',
                'åä½': 'è¿‡ä½',
                'è†ç›–': 'è†ç›–',
                'å¼¯æ›²': 'å¼¯æ›²',
                'ä¼¸ç›´': 'ä¼¸ç›´',
                'æ—¶æœº': 'æ—¶æœº',
                'è¿‡æ—©': 'å¤ªæ—©',
                'è¿‡æ™š': 'å¤ªæ™š',
                'è§’åº¦': 'è§’åº¦',
                'ä½ç½®': 'ä½ç½®',
                'è°ƒæ•´': 'è°ƒæ•´',
                'æ”¹è¿›': 'æ”¹è¿›',
                'ä¿æŒ': 'ä¿æŒ',
                'æ³¨æ„': 'æ³¨æ„',
                'å»ºè®®': 'å»ºè®®',
                'éœ€è¦': 'éœ€è¦',
                'åº”è¯¥': 'åº”è¯¥',
                'å¯ä»¥': 'å¯ä»¥',
                'å†²æµªæ¿': 'æ¿å­',
                'èº«ä½“': 'èº«ä½“',
                'æ‰‹è‡‚': 'æ‰‹è‡‚',
                'æ³¢æµª': 'æµª',
                'æµ·æµª': 'æµª',
                'é€Ÿåº¦': 'é€Ÿåº¦',
                'æ§åˆ¶': 'æ§åˆ¶',
                'ç¨³å®š': 'ç¨³å®š',
                'æµç•…': 'æµç•…',
                'é™ä½': 'é™ä½',
                'æé«˜': 'æé«˜',
                'ç»ƒä¹ ': 'ç»ƒä¹ ',
                'è®­ç»ƒ': 'è®­ç»ƒ',
                'ç­‰å¾…': 'ç­‰',
                'è§‚å¯Ÿ': 'çœ‹',
                'è½¬å‘': 'è½¬',
                'èµ·èº«': 'èµ·èº«'
            };
            
            let text = originalText;
            
            // ç§»é™¤å¸¸è§çš„æ— ç”¨è¯æ±‡
            const removeWords = ['çš„', 'äº†', 'ç€', 'åœ¨', 'ä¸', 'å’Œ', 'æˆ–', 'ä½†æ˜¯', 'ç„¶è€Œ', 'å› æ­¤', 'æ‰€ä»¥', 'ç”±äº', 'å¦‚æœ', 'å½“', 'æ—¶å€™'];
            removeWords.forEach(word => {
                text = text.replace(new RegExp(word, 'g'), '');
            });
            
            // æå–å…³é”®åŠ¨ä½œè¯
            const actionKeywords = [];
            Object.keys(keywordMap).forEach(key => {
                if (text.includes(key)) {
                    actionKeywords.push(keywordMap[key]);
                }
            });
            
            // æ™ºèƒ½å¤„ç†é—®é¢˜+å»ºè®®æ ¼å¼
            if (actionKeywords.length > 0) {
                let result = '';
                
                // ä¼˜å…ˆçº§æ’åºï¼šé‡å¿ƒ > å§¿æ€ > æ—¶æœº > ä½ç½®
                const priority = ['é‡å¿ƒ', 'å§¿æ€', 'æ—¶æœº', 'ä½ç½®', 'å¹³è¡¡', 'è§’åº¦'];
                const sortedKeywords = actionKeywords.sort((a, b) => {
                    const aIndex = priority.indexOf(a);
                    const bIndex = priority.indexOf(b);
                    return (aIndex === -1 ? 999 : aIndex) - (bIndex === -1 ? 999 : bIndex);
                });
                
                // ä¸»è¦é—®é¢˜è¯
                result = sortedKeywords[0] || '';
                
                // æ™ºèƒ½æ·»åŠ é—®é¢˜æè¿°
                if (text.includes('è¿‡é«˜') || text.includes('åé«˜')) {
                    result += 'è¿‡é«˜';
                } else if (text.includes('è¿‡ä½') || text.includes('åä½')) {
                    result += 'è¿‡ä½';
                } else if (text.includes('å¤ªæ—©') || text.includes('è¿‡æ—©')) {
                    result += 'å¤ªæ—©';
                } else if (text.includes('å¤ªæ™š') || text.includes('è¿‡æ™š')) {
                    result += 'å¤ªæ™š';
                } else if (text.includes('ä¸ç¨³') || text.includes('ä¸å¥½')) {
                    result += 'ä¸ç¨³';
                }
                
                // ä¸æ·»åŠ ä»»ä½•é¢„è®¾å»ºè®®ï¼Œåªä¿ç•™AIåŸå§‹å†…å®¹
                
                if (result.length <= 25 && result.length > 2) return result;
            }
            
            // å¤‡ç”¨æ–¹æ¡ˆï¼šæå–å¥å­ä¸­çš„æ ¸å¿ƒéƒ¨åˆ†
            const sentences = originalText.split(/[ã€‚ï¼ï¼Ÿ.!?]/);
            if (sentences.length > 0) {
                const firstSentence = sentences[0].trim();
                if (firstSentence.length <= 20) return firstSentence;
                
                // æ™ºèƒ½æˆªå–ï¼šä¿æŒè¯æ±‡å®Œæ•´æ€§
                const words = firstSentence.split('');
                let result = '';
                for (let i = 0; i < words.length && result.length < 18; i++) {
                    result += words[i];
                }
                return result + '..';
            }
            
            // æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆ
            return originalText.substring(0, 18) + '..';
        }

        // ä»çº¯æ–‡å­—ä¸­æå–ä¿¡æ¯ï¼ˆå½“AIä¸è¿”å›JSONæ—¶ï¼‰
        function extractInfoFromText(text) {
            console.log('ğŸ“„ AIè¿”å›çº¯æ–‡å­—ï¼Œä¸ç”Ÿæˆæ ‡æ³¨:', text.substring(0, 100) + '...');
            return {
                analysis: text,
                annotations: []  // ç»å¯¹ä¸ç”Ÿæˆä»»ä½•å‡æ ‡æ³¨
            };
        }

        // æ›´æ–°å½“å‰æ ‡æ³¨
        function updateCurrentAnnotations() {
            if (!annotationsVisible || !ctx || analysisResults.length === 0) {
                console.log('âŒ æ ‡æ³¨æ›´æ–°è·³è¿‡:', { 
                    annotationsVisible, 
                    hasCtx: !!ctx, 
                    resultsCount: analysisResults.length,
                    canvasWidth: canvas ? canvas.width : 'no canvas',
                    canvasHeight: canvas ? canvas.height : 'no canvas'
                });
                return;
            }

            const videoPlayer = document.getElementById('videoPlayer');
            const currentTime = videoPlayer.currentTime;
            
            // æŸ¥æ‰¾å½“å‰æ—¶é—´çš„åˆ†æ
            const currentAnalysis = analysisResults.find(result => 
                Math.abs(currentTime - result.timePoint) < 0.3
            );

            console.log('ğŸ” æŸ¥æ‰¾æ ‡æ³¨:', { currentTime, resultsCount: analysisResults.length, found: !!currentAnalysis });

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (currentAnalysis) {
                console.log('âœ… æ‰¾åˆ°åˆ†æç»“æœ:', currentAnalysis);
                drawAnnotations(currentAnalysis);
                showCurrentAnalysis(currentAnalysis);
                // æ£€æŸ¥æ˜¯å¦éœ€è¦æš‚åœï¼ˆåœ¨ç»˜åˆ¶å®Œæˆåï¼‰
                checkAndPauseForAnnotations(currentAnalysis);
            } else {
                console.log('âŒ æœªæ‰¾åˆ°åŒ¹é…çš„åˆ†æç»“æœ');
                document.getElementById('currentAnalysis').style.display = 'none';
            }
        }

        // æ£€æŸ¥å¹¶æš‚åœè§†é¢‘ä»¥æ˜¾ç¤ºæ ‡æ³¨
        function checkAndPauseForAnnotations(analysisData) {
            if (!analysisData.annotations || analysisData.annotations.length === 0) return;
            
            const videoPlayer = document.getElementById('videoPlayer');
            if (!videoPlayer) return;
            
            const currentTime = videoPlayer.currentTime;
            
            // å¦‚æœè¿™ä¸ªæ—¶é—´ç‚¹å·²ç»æš‚åœè¿‡ï¼Œå°±ä¸å†æš‚åœ
            if (Math.abs(currentTime - lastPausedTime) < 0.5) {
                return;
            }
            
            // å¦‚æœå½“å‰æ²¡æœ‰åœ¨æš‚åœçŠ¶æ€ï¼Œä¸”æœ‰æ ‡æ³¨è¦æ˜¾ç¤ºï¼Œä¸”è§†é¢‘æ­£åœ¨æ’­æ”¾
            if (!isPausedForAnnotation && videoPlayer && !videoPlayer.paused) {
                console.log('ğŸ¯ æ£€æµ‹åˆ°æ ‡æ³¨ï¼Œæš‚åœè§†é¢‘2ç§’');
                videoPlayer.pause();
                isPausedForAnnotation = true;
                lastPausedTime = currentTime; // è®°å½•æš‚åœçš„æ—¶é—´ç‚¹
                
                // æ˜¾ç¤ºæš‚åœæŒ‡ç¤ºå™¨
                showPauseIndicator();
                
                // 2ç§’åè‡ªåŠ¨æ¢å¤æ’­æ”¾
                setTimeout(() => {
                    if (isPausedForAnnotation && videoPlayer) {
                        console.log('â–¶ï¸ æ¢å¤è§†é¢‘æ’­æ”¾');
                        videoPlayer.play();
                        isPausedForAnnotation = false;
                        hidePauseIndicator();
                    }
                }, 2000);
            }
        }

        // æ˜¾ç¤ºæš‚åœæŒ‡ç¤ºå™¨
        function showPauseIndicator() {
            let indicator = document.getElementById('pauseIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'pauseIndicator';
                indicator.className = 'pause-indicator';
                indicator.textContent = 'â¸ï¸ æ ‡æ³¨æš‚åœä¸­...';
                document.body.appendChild(indicator);
            }
            indicator.style.display = 'block';
        }

        // éšè—æš‚åœæŒ‡ç¤ºå™¨
        function hidePauseIndicator() {
            const indicator = document.getElementById('pauseIndicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        }

        // ç»˜åˆ¶æ ‡æ³¨
        function drawAnnotations(analysisData) {
            if (!analysisData.annotations) {
                console.log('âŒ æ²¡æœ‰æ ‡æ³¨æ•°æ®');
                return;
            }

            console.log('ğŸ¨ å¼€å§‹ç»˜åˆ¶æ ‡æ³¨:', analysisData.annotations.length, 'ä¸ªæ ‡æ³¨');

            const colors = {
                surfer: '#ff5722',
                board: '#2196f3', 
                wave: '#4caf50'
            };

            analysisData.annotations.forEach((annotation, index) => {
                const x = (annotation.x / 100) * canvas.width;
                const y = (annotation.y / 100) * canvas.height;
                const color = colors[annotation.type] || '#ff5722';

                console.log(`ğŸ¯ ç»˜åˆ¶æ ‡æ³¨ ${index + 1}:`, { x, y, text: annotation.text, type: annotation.type });

                // ç»˜åˆ¶ç®­å¤´
                drawArrow(x, y, color);
                
                // ç»˜åˆ¶æ–‡å­—
                drawText(x, y, annotation.text, color);
            });
        }

        // ç»˜åˆ¶ç®­å¤´
        function drawArrow(x, y, color) {
            ctx.save();
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 4;

            if (showShadow) {
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
            }

            // æ›´æ˜æ˜¾çš„ç®­å¤´ - ä»ä¸Šæ–¹æŒ‡å‘ç›®æ ‡
            const startX = x - 30;
            const startY = y - 30;
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(x, y);
            ctx.stroke();

            // æ›´å¤§çš„ç®­å¤´å¤´éƒ¨
            const angle = Math.atan2(y - startY, x - startX);
            const arrowLength = 15;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(
                x - arrowLength * Math.cos(angle - Math.PI / 7),
                y - arrowLength * Math.sin(angle - Math.PI / 7)
            );
            ctx.moveTo(x, y);
            ctx.lineTo(
                x - arrowLength * Math.cos(angle + Math.PI / 7),
                y - arrowLength * Math.sin(angle + Math.PI / 7)
            );
            ctx.stroke();

            // åœ¨ç®­å¤´å°–ç«¯ç”»ä¸€ä¸ªå°åœ†ç‚¹ï¼Œæ›´æ˜æ˜¾åœ°æ ‡ç¤ºç›®æ ‡
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fill();

            ctx.restore();
        }

        // ç»˜åˆ¶æ–‡å­—
        function drawText(x, y, text, color) {
            ctx.save();
            ctx.font = 'bold 14px Arial';
            
            const metrics = ctx.measureText(text);
            const textWidth = metrics.width;
            const textHeight = 16;
            const padding = 8;

            // æ™ºèƒ½æ–‡å­—å®šä½ - é¿å…ä¸ç®­å¤´é‡å ï¼Œä¼˜å…ˆæ”¾åœ¨å³ä¾§
            let textX = x + 40;  // é»˜è®¤æ”¾åœ¨ç›®æ ‡å³ä¾§
            let textY = y - 10;

            // è¾¹ç•Œæ£€æŸ¥å’Œè°ƒæ•´
            if (textX + textWidth + padding * 2 > canvas.width - 10) {
                textX = x - textWidth - padding * 2 - 40;  // æ”¾åœ¨å·¦ä¾§
            }
            if (textX < 10) textX = 10;
            
            if (textY < textHeight + padding) textY = textHeight + padding;
            if (textY > canvas.height - padding) textY = y + 40;

            // èƒŒæ™¯
            ctx.fillStyle = `rgba(255, 255, 255, ${textOpacity})`;
            ctx.fillRect(textX - padding, textY - textHeight - padding/2, textWidth + padding * 2, textHeight + padding);

            // è¾¹æ¡†
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.strokeRect(textX - padding, textY - textHeight - padding/2, textWidth + padding * 2, textHeight + padding);

            // æ–‡å­—é˜´å½±
            if (showShadow) {
                ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                ctx.shadowBlur = 2;
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
            }

            // æ–‡å­—
            ctx.fillStyle = color;
            ctx.fillText(text, textX, textY);

            ctx.restore();
        }

        // æ˜¾ç¤ºå½“å‰åˆ†æ
        function showCurrentAnalysis(analysisData) {
            const currentAnalysis = document.getElementById('currentAnalysis');
            const currentAnalysisText = document.getElementById('currentAnalysisText');
            
            currentAnalysisText.innerHTML = `
                <strong>â±ï¸ ${analysisData.timePoint.toFixed(1)}ç§’ - ${analysisData.description}</strong><br>
                ${analysisData.analysis}
            `;
            
            currentAnalysis.style.display = 'block';
        }

        // æ˜¾ç¤ºç»“æœ
        function displayResults() {
            const analysisSection = document.getElementById('analysisSection');
            const analysisContent = document.getElementById('analysisContent');
            
            let content = '';
            analysisResults.forEach(result => {
                content += `
                    <div class="analysis-item">
                        <div class="time-stamp">â±ï¸ ${result.timePoint.toFixed(1)}ç§’ - ${result.description}</div>
                        <div class="analysis-text">${result.analysis}</div>
                        <small>æ ‡æ³¨æ•°é‡: ${result.annotations.length}</small>
                    </div>
                `;
            });
            
            analysisContent.innerHTML = content;
            analysisSection.style.display = 'block';
        }

        // æ›´æ–°è¿›åº¦
        function updateProgress(percent, text) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            progressFill.style.width = percent + '%';
            progressFill.textContent = Math.round(percent) + '%';
            progressText.textContent = text;
        }

        // æ˜¾ç¤ºé”™è¯¯
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            
            document.querySelector('.container').appendChild(errorDiv);
            
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }

        // å»¶è¿Ÿå‡½æ•°
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>
